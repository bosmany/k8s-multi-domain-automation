# Kubernetes Multi-Domain Automation Project

## **Overview**
This repository showcases a comprehensive Kubernetes project that automates the setup of a production-ready Kubernetes environment. It integrates multiple advanced features, including:

- **Multi-Domain Hosting**: Route traffic for multiple domains to different services within a Kubernetes cluster.
- **Automated TLS Certificates**: Secure all domains with TLS certificates issued by Cert-Manager using Let's Encrypt.
- **Monitoring and Logging**: Implement robust monitoring with Prometheus and Grafana and centralized logging with the ELK stack (Elasticsearch, Logstash, Kibana).

This project is ideal for mastering Kubernetes and cloud-native application management, covering both basic and advanced concepts.

---

## **Features**

### **Core Features**
1. **EKS Cluster Setup**:
   - Deploy a Kubernetes cluster on AWS using Elastic Kubernetes Service (EKS).
   - Provision and configure clusters manually without Terraform.

2. **NGINX Ingress Controller**:
   - Manage external traffic with NGINX Ingress.
   - Configure rules for routing traffic to multiple domains (e.g., `api1.example.com`, `api2.example.com`).

3. **Cert-Manager for TLS**:
   - Automate certificate issuance and renewal with Let's Encrypt.
   - Use HTTP-01 challenges to validate domain ownership.

4. **Prometheus and Grafana**:
   - Monitor cluster and application performance.
   - Pre-built dashboards for NGINX Ingress metrics.

5. **ELK Stack**:
   - Centralized logging for NGINX Ingress and Kubernetes pods.
   - Analyze traffic patterns and errors using Kibana.

### **Advanced Features**
1. **Manual Resource Management**:
   - Focus on creating Kubernetes resources directly using YAML manifests.

2. **Multi-Domain Hosting**:
   - Route multiple subdomains to separate backend services.
   - Example subdomains: `api1.example.com`, `api2.example.com`.

3. **TLS Automation**:
   - Fully automated HTTPS setup.
   - Certificates are renewed without manual intervention.

4. **Monitoring and Logging**:
   - Real-time metrics for HTTP requests, errors, and latency.
   - Centralized log aggregation and analysis.

---

## **Architecture**
### **Components**
1. **AWS EKS**: Managed Kubernetes cluster for hosting applications.
2. **NGINX Ingress Controller**: Routes HTTP/S traffic to services.
3. **Cert-Manager**: Automates TLS certificates with Let's Encrypt.
4. **Prometheus and Grafana**: Provides observability and metrics visualization.
5. **ELK Stack**: Centralized logging solution for analyzing NGINX and application logs.

### **Diagram**
```text
Client
 ├───└─── DNS (Route 53)
                 └───└─── AWS Load Balancer (Ingress Controller)
                                    └─── Kubernetes Services
                                            └─── Backend Pods
```

---

## **Setup Instructions**

### **Prerequisites**
1. **Tools**:
   - AWS CLI
   - `kubectl`

2. **AWS Resources**:
   - Access to an AWS account.
   - A domain managed in Route 53.

### **Steps**

#### **1. Provision EKS Cluster**
- Create an EKS cluster manually using AWS Management Console or AWS CLI.
- Ensure that the cluster is accessible using `kubectl`:
  ```bash
  aws eks --region <region> update-kubeconfig --name <cluster-name>
  kubectl get nodes
  ```

#### **2. Deploy NGINX Ingress Controller**
1. Download the NGINX Ingress Controller manifest:
   ```bash
   kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
   ```
2. Verify that the Ingress Controller is running:
   ```bash
   kubectl get pods -n ingress-nginx
   ```

#### **3. Deploy Sample Applications**
1. Deploy two sample services (`api` and `frontend`) with YAML manifests.
2. Create a multi-domain Ingress resource to route traffic.

#### **4. Install Cert-Manager**
1. Apply the Cert-Manager manifests:
   ```bash
   kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.12.0/cert-manager.yaml
   ```
2. Create a ClusterIssuer for Let's Encrypt:
   ```yaml
   apiVersion: cert-manager.io/v1
   kind: ClusterIssuer
   metadata:
     name: letsencrypt-prod
   spec:
     acme:
       server: https://acme-v02.api.letsencrypt.org/directory
       email: admin@example.com
       privateKeySecretRef:
         name: letsencrypt-prod
       solvers:
       - http01:
           ingress:
             class: nginx
   ```
3. Apply the manifest and verify:
   ```bash
   kubectl apply -f cluster-issuer.yaml
   ```

#### **5. Set Up Prometheus and Grafana**
1. Deploy Prometheus and Grafana using Kubernetes manifests.
2. Forward ports to access Grafana locally:
   ```bash
   kubectl port-forward svc/grafana 3000:3000 -n monitoring
   ```
3. Import pre-built NGINX dashboards to visualize metrics.

#### **6. Deploy ELK Stack**
1. Deploy Elasticsearch, Logstash, and Kibana using YAML manifests.
2. Forward Kibana's port to access it locally:
   ```bash
   kubectl port-forward svc/kibana 5601:5601
   ```

---

## **Testing and Validation**

1. **DNS Resolution**:
   - Ensure DNS records resolve to the NGINX Ingress Controller's external IP.

2. **TLS Certificates**:
   - Verify certificates are issued by Let's Encrypt and valid for each domain.

3. **Monitoring**:
   - Access Grafana dashboards to view metrics for request rates, latency, and errors.

4. **Logging**:
   - Use Kibana to analyze logs for traffic patterns and errors.

---

## **Future Enhancements**
1. **OIDC Authentication**:
   - Secure APIs with OAuth/OpenID Connect.

2. **Horizontal Autoscaling**:
   - Automatically scale backend services based on traffic.

3. **Canary Deployments**:
   - Gradually roll out new versions of applications using NGINX annotations.

---

## **Contributing**
Feel free to open issues or submit pull requests to improve this project. Contributions are welcome!

---

## **License**
This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

---

## **Acknowledgments**
Special thanks to the Kubernetes community for their tools and documentation, which made this project possible.

